## 不同GC对比总结

#### 串行GC  相比于 并行GC：

两者都需要STW，并行GC 相对于串行GC采用多线程执行GC操作，执行更快，效率更高，STW 时间更短。



#### 并行GC  相对于 CMS GC：

对老年代进行的垃圾回收算法有区分，并行GC 采用的是 标记-清除-整理 算法，而CMS GC 采用的是 标记-清除 算法； CMS GC 的垃圾回收六个阶段只有两个标记阶段存在 STW，其它四个阶段能够跟业务并发执行。

整体而言，CMS GC 的优势是 STW 时间更短，可以跟业务并发执行，减少业务延迟；并行GC则效率更高，能达到更高的吞吐量。



#### CMS GC 相对于 G1 GC: 

G1 GC 可以看作是 CMS GC 的升级版，拥有更低且较为可控的延迟，是将内存分为不同的块来进行垃圾回收。正因为将内存分为块进行管理，比较适合内存更大的场景应用，否则容易因大对象导致内存不足。

使用 G1 GC 需要注意的是：

> 某些情况下，G1 触发了 Full GC，G1 GC 会退化使用 串行GC 进行垃圾清理的工作。
>
> 这个时候可以考虑从 堆大小、并发线程数量 方向考虑优化；如果是有大对象导致内存不足够分配，可考虑修改 G1 内存块大小的配置，将内存块配置大一点。